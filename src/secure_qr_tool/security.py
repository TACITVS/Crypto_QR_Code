"""Security primitives used by the Secure QR Code Tool."""
from __future__ import annotations

import base64
import binascii
import os
from dataclasses import dataclass, field
from typing import Dict

from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from mnemonic import Mnemonic

from .config import AppConfig


class SecureString:
    """A mutable bytearray backed string that can be wiped from memory."""

    __slots__ = ("_data",)

    def __init__(self, data: bytes | str):
        if isinstance(data, bytes):
            self._data = bytearray(data)
        else:
            self._data = bytearray(data.encode("utf-8"))

    def get(self) -> str:
        """Return the string representation using UTF-8 decoding."""

        return self._data.decode("utf-8")

    def get_bytes(self) -> bytes:
        """Return a ``bytes`` view of the stored data."""

        return bytes(self._data)

    def copy(self) -> "SecureString":
        """Return a copy that owns its own backing buffer."""

        return SecureString(self.get_bytes())

    def clear(self) -> None:
        """Overwrite the backing buffer with zeros."""

        for index in range(len(self._data)):
            self._data[index] = 0
        self._data = bytearray()

    def __len__(self) -> int:  # pragma: no cover - trivial
        return len(self._data)

    def __enter__(self) -> "SecureString":  # pragma: no cover - trivial
        return self

    def __exit__(self, *_exc_info: object) -> None:  # pragma: no cover - trivial
        self.clear()

    def __del__(self):  # pragma: no cover - best effort cleanup
        try:
            self.clear()
        except Exception:
            pass


@dataclass(slots=True)
class CryptoManager:
    """High level facade around encryption primitives."""

    config: AppConfig

    def _derive_key(self, password: SecureString, salt: bytes) -> bytes:
        """Derive an AES key from ``password`` using PBKDF2."""

        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=self.config.aes_key_size_bytes,
            salt=salt,
            iterations=self.config.pbkdf2_iterations,
            backend=default_backend(),
        )
        return kdf.derive(password.get_bytes())

    def encrypt(self, data: SecureString, password: SecureString) -> Dict[str, str]:
        """Encrypt ``data`` using AES-256-GCM.

        The method returns a JSON serialisable dictionary containing the salt,
        nonce and ciphertext encoded in base64.
        """

        salt = os.urandom(self.config.salt_size_bytes)
        key = self._derive_key(password, salt)
        aesgcm = AESGCM(key)
        nonce = os.urandom(12)
        ciphertext = aesgcm.encrypt(nonce, data.get_bytes(), None)

        return {
            "salt": base64.b64encode(salt).decode("ascii"),
            "nonce": base64.b64encode(nonce).decode("ascii"),
            "ciphertext": base64.b64encode(ciphertext).decode("ascii"),
            "version": self.config.app_version,
        }

    def decrypt(self, payload: Dict[str, str], password: SecureString) -> SecureString:
        """Decrypt the dictionary generated by :meth:`encrypt`."""

        required = {"salt", "nonce", "ciphertext"}
        missing = required.difference(payload)
        if missing:
            raise ValueError(f"Invalid payload, missing fields: {sorted(missing)}")

        try:
            salt = base64.b64decode(payload["salt"])
            nonce = base64.b64decode(payload["nonce"])
            ciphertext = base64.b64decode(payload["ciphertext"])
        except (TypeError, binascii.Error) as exc:  # pragma: no cover - hard to trigger intentionally
            raise ValueError("Payload contains invalid base64 data") from exc

        key = self._derive_key(password, salt)
        aesgcm = AESGCM(key)

        try:
            plaintext = aesgcm.decrypt(nonce, ciphertext, None)
        except Exception as exc:  # pragma: no cover - depends on ciphertext
            raise ValueError("Decryption failed") from exc

        return SecureString(plaintext)


@dataclass(slots=True)
class MnemonicManager:
    """Utility wrapper around the ``mnemonic`` package."""

    config: AppConfig
    _mnemonic: Mnemonic = field(init=False, repr=False)

    def __post_init__(self) -> None:
        object.__setattr__(self, "_mnemonic", Mnemonic("english"))

    def generate(self) -> str:
        return self._mnemonic.generate(strength=self.config.mnemonic_strength_bits)

    def validate(self, mnemonic: str) -> bool:
        return self._mnemonic.check(mnemonic)

    @staticmethod
    def checksum(mnemonic: str) -> str:
        import hashlib

        return hashlib.sha256(mnemonic.encode("utf-8")).hexdigest()[:6].upper()


__all__ = ["SecureString", "CryptoManager", "MnemonicManager"]
